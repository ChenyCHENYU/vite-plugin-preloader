// ============================================================================
// âš¡ src/runtime.ts - è¿è¡Œæ—¶ä»£ç æ¨¡æ¿ï¼ˆå­—ç¬¦ä¸²ï¼‰
// ============================================================================
export const runtimeTemplate = `// ðŸš€ Auto-generated by vite-plugin-preloader
(function() {
  'use strict';
  
  // ðŸŽ¯ é¢„åŠ è½½é…ç½®ï¼ˆæž„å»ºæ—¶æ³¨å…¥ï¼‰
  const PRELOAD_ROUTES = __PRELOAD_ROUTES__
  const PRELOAD_OPTIONS = __PRELOAD_OPTIONS__

  class PreloaderManager {
    constructor() {
      this.preloadedRoutes = new Set()
      this.isPreloading = false
      this.stats = {
        total: 0, completed: 0, failed: 0, startTime: 0, endTime: 0
      }
      this.statusElement = null
    }

    async start() {
      if (this.isPreloading) return

      this.isPreloading = true
      this.stats = {
        total: PRELOAD_ROUTES.length,
        completed: 0, failed: 0,
        startTime: Date.now(), endTime: 0
      }

      if (PRELOAD_OPTIONS.debug) {
        console.log(\`ðŸš€ [é¢„åŠ è½½] å¼€å§‹é¢„åŠ è½½ \${PRELOAD_ROUTES.length} ä¸ªé¡µé¢\`)
      }

      // æ˜¾ç¤ºçŠ¶æ€æŒ‡ç¤ºå™¨
      this.showStatus()

      const sortedRoutes = [...PRELOAD_ROUTES].sort((a, b) => a.priority - b.priority)
      
      for (const route of sortedRoutes) {
        await this.preloadSingle(route)
        this.updateStatus()
        await this.sleep(100)
      }

      this.stats.endTime = Date.now()
      this.isPreloading = false
      
      if (PRELOAD_OPTIONS.debug) {
        console.log(\`ðŸŽ‰ [é¢„åŠ è½½] å®Œæˆ! è€—æ—¶ \${this.stats.endTime - this.stats.startTime}ms\`)
      }

      // éšè—çŠ¶æ€æŒ‡ç¤ºå™¨
      this.hideStatus()
    }

    async preloadSingle(route) {
      if (this.preloadedRoutes.has(route.path)) return

      try {
        const startTime = Date.now()
        // ä½¿ç”¨ eval æ¥åŠ¨æ€æ‰§è¡Œå¯¼å…¥å‡½æ•°å­—ç¬¦ä¸²
        const importFn = eval('(' + route.component + ')')
        await importFn()
        const loadTime = Date.now() - startTime
        
        this.preloadedRoutes.add(route.path)
        this.stats.completed++
        
        if (PRELOAD_OPTIONS.debug) {
          console.log(\`âœ… [é¢„åŠ è½½] \${route.path} (\${loadTime}ms) - \${route.reason}\`)
        }
      } catch (error) {
        this.stats.failed++
        if (PRELOAD_OPTIONS.debug) {
          console.error(\`âŒ [é¢„åŠ è½½] \${route.path} å¤±è´¥:\`, error)
        }
      }
    }

    showStatus() {
      if (!PRELOAD_OPTIONS.showStatus || !document.body) return

      // æ·»åŠ æ ·å¼
      if (!document.getElementById('preloader-styles')) {
        const style = document.createElement('style')
        style.id = 'preloader-styles'
        const position = PRELOAD_OPTIONS.statusPosition.replace('-', ': 20px; ') + ': 20px;'
        style.textContent = \`
          .preloader-status {
            position: fixed; \${position}
            background: rgba(0,0,0,0.8); color: white; padding: 8px 16px;
            border-radius: 6px; font-size: 12px; z-index: 9999;
            pointer-events: none; font-family: system-ui;
            transition: opacity 0.3s ease;
          }
          .preloader-status.fade-out {
            opacity: 0;
          }
        \`
        document.head.appendChild(style)
      }

      // åˆ›å»ºçŠ¶æ€å…ƒç´ 
      this.statusElement = document.createElement('div')
      this.statusElement.className = 'preloader-status'
      this.updateStatus()
      document.body.appendChild(this.statusElement)
    }

    updateStatus() {
      if (!this.statusElement) return
      this.statusElement.textContent = \`ðŸ”„ æ­£åœ¨ä¼˜åŒ–é¡µé¢... \${this.stats.completed}/\${this.stats.total}\`
    }

    hideStatus() {
      if (!this.statusElement) return
      this.statusElement.classList.add('fade-out')
      setTimeout(() => {
        if (this.statusElement && this.statusElement.parentNode) {
          this.statusElement.parentNode.removeChild(this.statusElement)
        }
      }, 300)
    }

    sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms))
    }

    isPreloaded(path) {
      return this.preloadedRoutes.has(path)
    }

    getStats() {
      return {
        ...this.stats,
        preloadedPaths: Array.from(this.preloadedRoutes),
        isPreloading: this.isPreloading
      }
    }
  }

  // ðŸš€ å…¨å±€å®žä¾‹
  const preloader = new PreloaderManager()

  // ðŸ› ï¸ å¼€å‘çŽ¯å¢ƒè°ƒè¯•å·¥å…·
  if (PRELOAD_OPTIONS.debug) {
    window.preloaderDebug = {
      stats: () => preloader.getStats(),
      restart: () => preloader.start(),
      check: (path) => preloader.isPreloaded(path),
      help: () => console.log('ðŸ› ï¸ é¢„åŠ è½½è°ƒè¯•: stats() | restart() | check(path)')
    }
    console.log('ðŸ› ï¸ é¢„åŠ è½½è°ƒè¯•å·¥å…·: window.preloaderDebug')
  }

  // ðŸš€ è‡ªåŠ¨å¯åŠ¨ - ç­‰å¾… DOM åŠ è½½å®Œæˆ
  function autoStart() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => preloader.start(), PRELOAD_OPTIONS.delay)
      })
    } else {
      setTimeout(() => preloader.start(), PRELOAD_OPTIONS.delay)
    }
  }

  // ç«‹å³æ‰§è¡Œè‡ªåŠ¨å¯åŠ¨
  autoStart()

  // å¯¼å‡ºåˆ°å…¨å±€ï¼ˆå¯é€‰ä½¿ç”¨ï¼‰
  window.usePreloader = () => ({
    start: () => preloader.start(),
    isPreloaded: (path) => preloader.isPreloaded(path),
    getStats: () => preloader.getStats()
  })

})();`